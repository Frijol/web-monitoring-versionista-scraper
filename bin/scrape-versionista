#!/usr/bin/env node
'use strict';

const path = require('path');
const stream = require('stream');
const fs = require('fs-promise');
const mkdirp = require('mkdirp');
const neodoc = require('neodoc');
const unzip = require('unzip-stream');
const Versionista = require('..');
require('../lib/polyfill');

const formatters = {
  csv: require('../lib/formatters/csv.js'),
  'json-stream': require('../lib/formatters/json-stream.js'),
  json: require('../lib/formatters/json.js'),
};

const args = neodoc.run(`
Usage: scrape-versionista [options]

Options:
  -h, --help           Print this lovely help message.
  --email ADDRESS      E-mail address of Versionista Account.
                       You can also use an env var instead: VERSIONISTA_EMAIL
  --password PASSWORD  Password of Versionista Account.
                       You can also use an env var instead: VERSIONISTA_PASSWORD
  --after DATE         Only include versions after this date.
                       An ISO8601 date string like '2017-03-01T00:00:00Z'
                       Or a number, representing hours before the current time
  --before DATE        Only include versions created before this time.
                       An ISO8601 date string like '2017-03-01T00:00:00Z'
                       Or a number, representing hours before the current time
  --format FORMAT      Output format (csv|json|json-stream) [default: json]
  --output PATH        Write output to this file instead of STDOUT.
  --errors PATH        Write error summary to this file instead of STDERR.
  --save-content       Save raw HTML of each version. Files are written to the
                       working directory or, if --output is specified, the same
                       directory as the output file.
  --save-all-content   Like --save-content, but saves ALL versions, regardless
                       of --before/--after date criteria.
  --save-diffs         Save HTML of diffs between versions. Outputs in the same
                       fashion as --save-content.
`);

args['--email'] = args['--email'] || process.env.VERSIONISTA_EMAIL;
args['--password'] = args['--password'] || process.env.VERSIONISTA_PASSWORD;
if (!args['--email'] || !args['--password']) {
  console.error('You must specify an e-mail and password for Versionista, either with the --email and --password arguments or with environment variables (VERSIONISTA_EMAIL, VERSIONISTA_PASSWORD).');
}

if (args['--save-all-content']) {
  args['--save-content'] = 'all';
}

if (args['--before']) {
  if (typeof args['--before'] === 'number') {
    const millisAgo = args['--before'] * 60 * 60 * 1000;
    args['--before'] = new Date(Date.now() - millisAgo);
  }
  else {
    args['--before'] = new Date(args['--before']);
    if (isNaN(args['--before'])) {
      console.error('--before must be a valid date or number.');
      process.exit(1);
    }
  }
}

if (args['--after']) {
  if (typeof args['--after'] === 'number') {
    const millisAgo = args['--after'] * 60 * 60 * 1000;
    args['--after'] = new Date(Date.now() - millisAgo);
  }
  else {
    args['--after'] = new Date(args['--after']);
    if (isNaN(args['--after'])) {
      console.error('--after must be a valid date or number.');
      process.exit(1);
    }
  }
}

function outputFileName (version, tag = 'content', extension = 'html') {
  return `${version.siteId}-${version.pageId}-${version.versionId}-${tag}.${extension}`;
}

let directoryIsReady = false;
function writeFile (name, content, encoding = 'utf8') {
  let directory = process.cwd();
  if (args['--output']) {
    directory = path.dirname(args['--output']);
  }

  const filePath = path.join(directory, name);
  const writeIt = () => fs.writeFile(filePath, content, encoding);

  if (!directoryIsReady) {
    return new Promise((resolve, reject) => {
      mkdirp(directory, (error, created) => {
        if (error) return reject(error);
        directoryIsReady = true;
        resolve(created);
      });
    }).then(writeIt)
  }

  return writeIt();
}

let errorStream;
function writeError (error) {
  if (!errorStream) {
    if (args['--errors']) {
      errorStream = fs.createWriteStream(args['--errors']);
    }
    else {
      errorStream = process.stderr;
    }
  }

  errorStream.write(error);
  errorStream.write('\n');
}

function flushErrors () {
  if (errorStream && errorStream !== process.stderr) {
    errorStream.end();
  }
}

function pageHasDownloadableVersions (page) {
  return page.versions.some(version => version.hasContent);
}

function minimum (items, getValue = Number) {
  let smallestValue = Infinity;
  let smallestItem = null;
  for (let item of items) {
    let value = getValue(item);
    if (value != null && value < smallestValue) {
      smallestValue = value;
      smallestItem = item;
    }
  }
  return smallestItem;
}

const scraper = new Versionista({
  email: args['--email'],
  password: args['--password']
});

const isAfterMinimumDate = (testDate) => {
  return !args['--after'] || args['--after'] <= testDate;
};

const isInRequestedDateRange = (testDate) => {
  return isAfterMinimumDate(testDate) &&
    (!args['--before'] || args['--before'] >= testDate);
}

const formatter = formatters[args['--format']] || formatters.json;
const startTime = Date.now();

let encounteredErrors = 0;
let basicMetadata = scraper.logIn()
  .then(() => scraper.getSites())
  // TODO: rewrite this as a series or more readable sequential transforms
  // instead of nested ones.
  .then(siteData => {
    const updatedSites = siteData.filter(site => isAfterMinimumDate(site.lastChange));
    let totalSites = updatedSites.length;
    let completedSites = 0;
    console.error(`Found ${totalSites} (of ${siteData.length}) sites with updates.`);

    return Promise.all(updatedSites.map(site => {
      return scraper.getPages(site.url)
        .then(pages => {
          completedSites++;
          const updatedPages = pages.filter(page => isAfterMinimumDate(page.lastChange));
          console.error(`Found ${pages.length} pages (${updatedPages.length} w/ updates) for ${site.name} (${completedSites}/${totalSites} sites checked)`);

          return Promise.all(updatedPages.map(page => {
            return scraper.getVersions(page.versionistaUrl)
              .then(versions => {
                const newVersions = versions.filter(version => isInRequestedDateRange(version.date));
                console.error(`In ${page.url}:\n  ${versions.length} versions\n  ${newVersions.length} new versions`);

                // FIXME: this is duplicated in the content-saving logic below
                let baseDirectory = process.cwd();
                if (args['--output']) {
                  baseDirectory = path.dirname(args['--output']);
                }
                const pageDirectory = `${site.id}-${page.id}`;
                const pagePath = path.join(baseDirectory, pageDirectory);

                return Promise.all(newVersions.map(version => {
                  if (!version.diffWithPreviousUrl) return version;
                  return scraper.getVersionDiff(version.diffWithPreviousUrl)
                    .then(diff => {
                      if (diff) {
                        version.diff = {
                          hash: diff.hash,
                          length: diff.length
                        };

                        if (args['--save-diffs']) {
                          const diffPath = path.join(
                            pagePath,
                            `diff-${version.versionId}.html`
                          );
                          version.diff.path = diffPath;
                          return fs.ensureDir(pagePath)
                            .then(() => fs.writeFile(diffPath, diff.content))
                            .then(() => version);
                        }
                      }

                      return version;
                    })
                    .catch(error => {
                      // itâ€™s possible for Versionista to consign a version to
                      // the ether between the time we detect the version and
                      // ask for the diff, so this is "ok"
                      // otherwise, log error but continue working
                      if (error.code !== 'VERSIONISTA:INVALID_URL') {
                        encounteredErrors++;
                        writeError(error.message);
                      }
                      return version;
                    });
                }))
                  // attach versions to pages
                  .then(versions => Object.assign({versions}, page));
              });
          }))
            // attach pages to site
            .then(pages => Object.assign({pages}, site));
        });
    }));
  });

function saveMetadata (sites) {
  return Promise.resolve(sites)
    .then(data => formatter(data, {
      email: args['--email'],
      includeDiffs: args['--save-diffs'],
      includeContent: args['--save-content'],
      outputFileName: outputFileName
    }))
    .then(formatted => {
      if (args['--output']) {
        return writeFile(path.basename(args['--output']), formatted);
      }
      else {
        process.stdout.write(formatted);
      }
    });
}

// save the metadata as-is before doing more work
saveMetadata(basicMetadata);

if (args['--save-content']) {
  const unmatchedVersions = new Set();
  basicMetadata = basicMetadata.then(sites => {
    const workTasks = [];
    sites.forEach(site => {
      site.pages
        .filter(pageHasDownloadableVersions)
        .forEach(page => {
          page.versions.forEach(version => {
            unmatchedVersions.add(version.versionId);
          });

          let baseDirectory = process.cwd();
          if (args['--output']) {
            baseDirectory = path.dirname(args['--output']);
          }
          const pageDirectory = `${site.id}-${page.id}`;
          const pagePath = path.join(baseDirectory, pageDirectory);
          const task = fs.ensureDir(pagePath)
            .then(() => scraper.getVersionArchive(page.versionistaUrl))
            .then(content => {
              return new Promise((resolve, reject) => {
                let writing = 1;
                let errors = [];
                const complete = (error) => {
                  error && errors.push(error);
                  writing = Math.max(0, writing - 1);
                  if (writing === 0) {
                    if (errors.length) {
                      reject(errors.map(error => error.message).join('\n'));
                    }
                    else {
                      resolve();
                    }
                  }
                };
                const contentStream = new stream.PassThrough();
                contentStream.end(content);
                contentStream.pipe(unzip.Parse())
                  .on('entry', entry => {
                    if (entry.type === 'File') {
                      const [_, year, month, day, hour, minute, second, extension = ''] =
                        entry.path.match(/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)[^\.]*(\..*)?$/);
                      const isoDate = `${year}-${month}-${day}T${hour}:${minute}:${second}Z`;
                      const fileDate = new Date(isoDate);

                      // Frustratingly, the timestamps on the files do not
                      // match the timestamps on the version records. So...
                      // find the closest matching timestamp, but also require
                      // it to be within a narrow threshold.
                      const allowableTimeframe = 5 * 60 * 1000;
                      const fileVersion = minimum(page.versions, version => {
                        const value = Math.abs(version.date - fileDate);
                        return (value < allowableTimeframe) ? value : null;
                      });

                      let outputName = entry.path;
                      if (fileVersion) {
                        outputName = `version-${fileVersion.versionId}${extension}`;
                        unmatchedVersions.delete(fileVersion.versionId);
                        fileVersion.filePath = path.join(pagePath, outputName);
                      }
                      else if (args['--save-content'] !== 'all') {
                        resolve();
                        entry.autodrain();
                        return;
                      }

                      const versionFile = path.join(pagePath, outputName);
                      entry
                        .pipe(fs.createWriteStream(versionFile))
                        .on('error', complete)
                        .on('close', () => complete());

                      writing++;
                    }
                    else {
                      entry.autodrain();
                    }
                  })
                  .on('end', () => complete());
              });
            })
            .catch(error => {
              // emit messages here and allow the process to continue
              encounteredErrors++;
              writeError(error.message);
            });
          workTasks.push(task);
        });
    });
    return Promise.all(workTasks)
      .then(tasks => {
        if (unmatchedVersions.size > 0) {
          encounteredErrors++;
          writeError(`${unmatchedVersions.size} versions not found in downloaded archives: ${Array.from(unmatchedVersions)}`);
        }
      })
      .then(() => sites);
  });
}

// save again to get any updates from downloading raw versions
saveMetadata(basicMetadata)
  .catch(error => {
    console.error(error.stack);
    encounteredErrors++;
  })
  .then(() => {
    const seconds = Math.round((Date.now() - startTime) / 1000);
    console.error(`Completed in ${seconds} seconds`);
    if (encounteredErrors) {
      console.error(`  with ${encounteredErrors} errors`);
    }
    flushErrors();
    process.exit(encounteredErrors ? 1 : 0);
  });
