#!/usr/bin/env node
'use strict';

const path = require('path');
const fs = require('fs-promise');
const neodoc = require('neodoc');
const mkdirp = require('mkdirp');
const Versionista = require('..');

const formatters = {
  csv: require('../lib/formatters/csv.js'),
  'json-stream': require('../lib/formatters/json-stream.js'),
  json: require('../lib/formatters/json.js'),
};

const args = neodoc.run(`
Usage: scrape-versionista [options]

Options:
  -h, --help           Print this lovely help message.
  --email ADDRESS      E-mail address of Versionista Account.
                       You can also use an env var instead: VERSIONISTA_EMAIL
  --password PASSWORD  Password of Versionista Account.
                       You can also use an env var instead: VERSIONISTA_PASSWORD
  --after DATE         Only include versions after this date.
                       An ISO8601 date string like '2017-03-01T00:00:00Z'
                       Or a number, representing hours before the current time
  --before DATE        Only include versions created before this time.
                       An ISO8601 date string like '2017-03-01T00:00:00Z'
                       Or a number, representing hours before the current time
  --format FORMAT      Output format (csv|json|json-stream) [default: json]
  --output PATH        Write output to this file instead of STDOUT.
  --save-content       Save raw HTML of each version. Files are written to the
                       working directory or, if --output is specified, the same
                       directory as the output file.
  --save-diffs         Save HTML of diffs between versions. Outputs in the same
                       fashion as --save-content.
`);

args['--email'] = args['--email'] || process.env.VERSIONISTA_EMAIL;
args['--password'] = args['--password'] || process.env.VERSIONISTA_PASSWORD;
if (!args['--email'] || !args['--password']) {
  console.error('You must specify an e-mail and password for Versionista, either with the --email and --password arguments or with environment variables (VERSIONISTA_EMAIL, VERSIONISTA_PASSWORD).');
}

if (args['--before']) {
  if (typeof args['--before'] === 'number') {
    const millisAgo = args['--before'] * 60 * 60 * 1000;
    args['--before'] = new Date(Date.now() - millisAgo);
  }
  else {
    args['--before'] = new Date(args['--before']);
    if (isNaN(args['--before'])) {
      console.error('--before must be a valid date or number.');
      process.exit(1);
    }
  }
}

if (args['--after']) {
  if (typeof args['--after'] === 'number') {
    const millisAgo = args['--after'] * 60 * 60 * 1000;
    args['--after'] = new Date(Date.now() - millisAgo);
  }
  else {
    args['--after'] = new Date(args['--after']);
    if (isNaN(args['--after'])) {
      console.error('--after must be a valid date or number.');
      process.exit(1);
    }
  }
}

function outputFileName (version, tag = 'content', extension = 'html') {
  return `${version.siteId}-${version.pageId}-${version.versionId}-${tag}.${extension}`;
}

let directoryIsReady = false;
function writeFile (name, content, encoding = 'utf8') {
  let directory = process.cwd();
  if (args['--output']) {
    directory = path.dirname(args['--output']);
  }

  const filePath = path.join(directory, name);
  const writeIt = () => fs.writeFile(filePath, content, encoding);

  if (!directoryIsReady) {
    return new Promise((resolve, reject) => {
      mkdirp(directory, (error, created) => {
        if (error) return reject(error);
        directoryIsReady = true;
        resolve(created);
      });
    }).then(writeIt)
  }

  return writeIt();
}

const scraper = new Versionista({
  email: args['--email'],
  password: args['--password']
});

const isAfterMinimumDate = (testDate) => {
  return !args['--after'] || args['--after'] <= testDate;
};

const isInRequestedDateRange = (testDate) => {
  return isAfterMinimumDate(testDate) &&
    (!args['--before'] || args['--before'] >= testDate);
}

const formatter = formatters[args['--format']] || formatters.json;
const startTime = Date.now();

let encounteredErrors = false;
scraper.logIn()
  .then(() => scraper.getSites())
  // TODO: rewrite this as a series or more readable sequential transforms
  // instead of nested ones.
  .then(siteData => {
    const updatedSites = siteData.filter(site => isAfterMinimumDate(site.lastChange));
    let totalSites = updatedSites.length;
    let completedSites = 0;
    console.error(`Found ${totalSites} (of ${siteData.length}) sites with updates.`);

    return Promise.all(updatedSites.map(site => {
      return scraper.getPages(site.url)
        .then(pages => {
          completedSites++;
          const updatedPages = pages.filter(page => isAfterMinimumDate(page.lastChange));
          console.error(`Found ${pages.length} pages (${updatedPages.length} w/ updates) for ${site.name} (${completedSites}/${totalSites} sites checked)`);

          return Promise.all(updatedPages.map(page => {
            return scraper.getVersions(page.versionistaUrl)
              .then(versions => {
                const newVersions = versions.filter(version => isInRequestedDateRange(version.date));
                console.error(`In ${page.url}:\n  ${versions.length} versions\n  ${newVersions.length} new versions`);

                return Promise.all(newVersions.map(version => {
                  if (!version.diffWithPreviousUrl) return version;
                  return scraper.getVersionDiff(version.diffWithPreviousUrl)
                    .then(diff => {
                      if (diff) {
                        version.diff = {
                          hash: diff.hash,
                          length: diff.length
                        };

                        if (args['--save-diffs']) {
                          return writeFile(
                            outputFileName(version, 'diff'),
                            diff.content
                          )
                          .then(() => version);
                        }
                      }

                      return version;
                    })
                    .catch(error => {
                      // itâ€™s possible for Versionista to consign a version to
                      // the ether between the time we detect the version and
                      // ask for the diff, so this is "ok"
                      if (error.code === 'VERSIONISTA:INVALID_URL') {
                        return version;
                      }
                      return Promise.reject(error);
                    });
                }))
                  // attach versions to pages
                  .then(versions => Object.assign({versions}, page));
              });
          }))
            // attach pages to site
            .then(pages => Object.assign({pages}, site));
        });
    }));
  })
  // save versions
  .then(sites => {
    if (!args['--save-content']) return sites;

    const workTasks = [];
    sites.forEach(site => {
      site.pages.forEach(page => {
        const savedArchive = scraper
          .getVersionArchive(page.versionistaUrl)
          .then(content => {
            const fileName = outputFileName(
              {
                siteId: site.id,
                pageId: page.id,
                versionId: 'all'
              },
              'archive',
              'zip');
            return writeFile(fileName, content, null);
          })
          .catch(error => {
            // emit messages here and allow the process to continue
            encounteredErrors = true;
            console.error(error.message);
          });
        workTasks.push(savedArchive);

        // page.versions.forEach(version => {
        //   if (version.hasContent && args['--save-content']) {
        //     const savedFile = scraper
        //       .getVersionRawContent(version.url)
        //       .then(html => writeFile(outputFileName(version), html))
        //       .catch(error => {
        //         encounteredErrors = true;

        //         // Do some nice logging for a failure to get content. Also
        //         // don't stop the works for this particular error.
        //         if (error.code === 'VERSIONISTA:NO_VERSION_CONTENT') {
        //           console.error(error.message);
        //           console.error('  Requested urls:', error.urls);
        //           console.error(`  Raw response: "${error.formattedContent}"`);
        //         }
        //         else {
        //           throw error;
        //         }
        //       });
        //     workTasks.push(savedFile);
        //   }
        // });
      });
    });
    return Promise.all(workTasks).then(() => sites);
  })
  // format and save
  .then(data => formatter(data, {
    email: args['--email'],
    includeDiffs: args['--save-diffs'],
    includeContent: args['--save-content'],
    outputFileName: outputFileName
  }))
  .then(formatted => {
    if (args['--output']) {
      return writeFile(path.basename(args['--output']), formatted);
    }
    else {
      process.stdout.write(formatted);
    }
  })
  .catch(error => {
    console.error(error.stack);
    encounteredErrors = true;
  })
  .then(() => {
    const seconds = Math.round((Date.now() - startTime) / 1000);
    console.error(`Completed in ${seconds} seconds`);
    process.exit(encounteredErrors ? 1 : 0);
  });
